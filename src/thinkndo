#!/usr/bin/env python3

# FIXME: ev_kb_

import sys
import argparse
import os
import shutil
import signal
import json
import logging
import copy
import uuid
from pathlib import Path
from PyQt5.Qt import *
from PyQt5 import QtCore

app_name = "doen"

keypress_items = [
    {"key": Qt.Key_A, "event": "edit"},
    {"key": Qt.Key_C, "event": "toggle_auto_collapse", "modifiers": Qt.ShiftModifier},
    {"key": Qt.Key_C, "event": "toggle_expanded"},
    {"key": Qt.Key_D, "event": "delete"},
    {"key": Qt.Key_H, "event": "cursor_left"},
    {"key": Qt.Key_J, "event": "move_down", "modifiers": Qt.ShiftModifier},
    {"key": Qt.Key_J, "event": "cursor_down"},
    {"key": Qt.Key_K, "event": "move_up", "modifiers": Qt.ShiftModifier},
    {"key": Qt.Key_K, "event": "cursor_up"},
    {"key": Qt.Key_L, "event": "cursor_right"},
    {"key": Qt.Key_O, "event": "insert_above", "modifiers": Qt.ShiftModifier},
    {"key": Qt.Key_O, "event": "insert_below"},
    {"key": Qt.Key_P, "event": "paste_above", "modifiers": Qt.ShiftModifier},
    {"key": Qt.Key_P, "event": "paste_below"},
    {"key": Qt.Key_Q, "event": "close"},
    {"key": Qt.Key_S, "event": "save"},
    {"key": Qt.Key_X, "event": "toggle_done"},
    {"key": Qt.Key_Z, "event": "dump"},
    {"key": Qt.Key_Escape, "event": "close"},
]

quick_icon_map = {
    "i ": "information.png",
    "! ": "warning.png",
    "+ ": "plus.png",
    "/ ": "folder.png",
    "? ": "question.png",
    "B ": "bug.png",
    "> ": "arrow_right.png",
    "* ": "bullet_black.png",
    "*g ": "bullet_green.png",
    "*b ": "bullet_blue.png",
    "*o ": "bullet_orange.png",
    "*r ": "bullet_red.png",
    "*p ": "bullet_purple.png",
    ": ": "clock.png",
    "^ ": "note.png",
    "!! ": "exclamation.png",
    "[] ": "check_box_uncheck.png",
    "db ": "database.png",
    "doc ": "document_editing.png",
    "usr ": "user.png",
    "ph ": "phone.png",
}

class Node:
    """
    Nodes represent a single leaf in the outline tree.
    """
    def __init__(self, title, icon=None, checked=False, expanded=False,
                 auto_collapse=False, uniq_id=None):
        self.title = title
        self.icon = icon
        self.checked = checked
        self.expanded = expanded
        self.auto_collapse = auto_collapse
        if uniq_id is not None:
            self.uniq_id = uniq_id
        else:
            self.uniq_id = uuid.uuid4().hex

    def get_icon(self):
        """
        Return the icon that should currently be used for this node.
        """
        if self.checked is True:
            return "check_box.png"
        else:
            return self.icon

    def copy(self):
        """
        Create a deep-copy of this node, and reset the checked state.
        """
        new_node = Node.from_dict(self.to_dict())
        new_node.uniq_id = uuid.uuid4().hex
        if new_node.checked is True:
            new_node.checked = False
        return new_node

    @staticmethod
    def from_dict(d):
        """
        Convert a dictionary representation of a node into an object
        of type Node.
        """
        node = Node(
            title=d["title"],
            icon=d["icon"],
            checked=d.get("checked", False),
            expanded=d.get("expanded", True),
            auto_collapse=d.get("auto_collapse", False),
            uniq_id=d.get("uniq_id", None),
        )

        return node

    def to_dict(self):
        """
        Convert this node to a dictionary representation.
        """
        s = {
            "uniq_id": self.uniq_id,
            "title": self.title,
            "icon": self.icon,
            "checked": self.checked,
            "expanded": self.expanded,
            "auto_collapse": self.auto_collapse,
        }

        return s

    def to_item(self):
        """
        Convert this Node to a QStandardItem.
        """
        icon = QIcon("icons/{}".format(self.get_icon()))
        item = QStandardItem(icon, self.title)
        item.setData(self)
        return item

    def __repr__(self):
        return "<Node uniq_id='{}', title='{}', icon={}, checked={}, expanded={} auto_collapse={}>".format(
            self.uniq_id, self.title, self.icon, self.checked, self.expanded, self.auto_collapse
        )


class GUI:
    """
    Main GUI class.
    """
    def __init__(self, path):
        self.path = path
        self.settings = QSettings("electricmonk", app_name)
        self.cursor = None
        self.del_buf = None

        # Main window
        self.win = QMainWindow()
        self.win.setWindowIcon(QIcon("thinkndo.png"))
        self.win.setWindowTitle("Think'n'Do")
        geometry = self.settings.value("geometry")
        if geometry is not None:
            self.win.restoreGeometry(geometry);

        # FIXME
        self.win.closeEvent = self._act_close

        # Node tree
        self.node_view = QTreeView(self.win)
        self.node_view.setWordWrap(True)
        self.node_model = QStandardItemModel(0, 1)
        self.node_model.setHorizontalHeaderLabels(
            [
                "",
            ]
        )
        self.node_view.setModel(self.node_model)
        self.node_root = self.node_model.invisibleRootItem()

        self.load(self.path)

        # Monkey-patch QTreeView's keyPressEvent. This would be cleaner of it
        # used inheritence, but would complicate the code.
        self.orig_node_view_keyPressEvent = self.node_view.keyPressEvent
        self.node_view.keyPressEvent = self.keyPressEvent

        # Signals
        self.node_view.expanded.connect(self._ev_expanded)
        self.node_view.collapsed.connect(self._ev_collapsed)
        self.node_view.selectionModel().currentChanged.connect(self._ev_current_changed)
        self.node_model.itemChanged.connect(self._ev_item_changed)

        self.win.setCentralWidget(self.node_view)
        self.win.show()

    def load(self, path):
        """
        Load a tree from a JSON file.
        """
        with open(path, "r") as f:
            tnd = json.load(f)

        self.cursor = tnd.get("cursor", None)
        self.deserialize(tnd["nodes"], self.node_root)

    def save(self, path):
        """
        Save a tree to a JSON file.
        """
        raw_nodes = self.serialize(self.node_root)
        tnd = {
            "cursor": self.cursor,
            "nodes": raw_nodes
        }

        with open(path, "w") as f:
            json.dump(tnd, f, indent=2)

    def insert_node(self, node, parent, row=None):
        """
        Insert a node into the tree. `parent` is a QStandardItem. Returns the
        newly created QStandardItem.
        """
        item = node.to_item()
        row_items = [item]

        if row is None:
            # Append at end of current level
            parent.appendRow(row_items)
            cur_item = parent.child(parent.rowCount() - 1)
        else:
            # Append at specified row
            parent.insertRow(row, row_items)

        index = self.node_model.indexFromItem(item)
        if node.expanded is True and node.auto_collapse is False:
            self.node_view.setExpanded(index, True)

        if node.uniq_id == self.cursor:
            self.node_view.setCurrentIndex(index)

        return item

    def get(self, index=None):
        """
        Return index, item, node, etc for `index`. If `index` is not given, it
        returns the currently selected index.
        """
        if index is None:
            index = self.node_view.currentIndex()
        item = self.node_model.itemFromIndex(index)
        if item is None:
            return None
        node = item.data()
        row = index.row()
        parent_item = item.parent()
        if parent_item is None:
            parent_item = self.node_root
        parent_index = index.parent()

        return {
            "index": index,
            "item": item,
            "node": node,
            "row": row,
            "parent_item": parent_item
        }

    def close(self):
        self.save(self.path)
        self.settings.setValue("geometry", self.win.saveGeometry())
        self.settings.sync()
        QCoreApplication.quit()

    def serialize(self, parent):
        """
        Serialize the QStandardItem `parent`, including its children to a
        Python dicts
        """
        raw_nodes = []
        for i in range(0, parent.rowCount()):
            item = parent.child(i)
            node = item.data()
            raw_node = node.to_dict()
            raw_nodes.append(raw_node)
            raw_node["children"] = self.serialize(item)

        return raw_nodes

    def deserialize(self, l, parent, row=None):
        """
        Deserialize dicts in list `l` into QStandardItemModels under `parent`.
        The dicts in `l` are converted to instances of Node() which are set as
        data on each of the items in the tree.
        """
        for child in l:
            node = Node.from_dict(child)
            tree = self.insert_node(node, parent)
            self.deserialize(child["children"], tree)

    def keyPressEvent(self, keypress):
        """
        Handle key press events. Looks in `keypress_items` for actions.
        """
        for keypress_item in keypress_items:
            if (
                keypress.key() == keypress_item["key"] and
                (
                    "modifiers" not in keypress_item or
                    (int(keypress.modifiers()) & keypress_item["modifiers"] == keypress_item["modifiers"])
                )
               ):
                event_cb = getattr(self, "_act_{}".format(keypress_item["event"]))
                event_cb()
                return
        self.orig_node_view_keyPressEvent(keypress)

    def _ev_expanded(self, index):
        cur = self.get(index)
        cur["node"].expanded = True
        self.save(self.path)

    def _ev_collapsed(self, index):
        item = self.get(index)
        item["node"].expanded = False
        self.save(self.path)

    def _ev_current_changed(self, new_index, prev_index):
        """
        Auto-collapse trees if user moves away from them.
        """
        new = self.get(new_index)
        prev = self.get(prev_index)

        assert new_index is not None
        if prev is None:
            return

        # Build a list of items that shouldn't be collapsed, because they're
        # parents of the new item we're switching to.
        no_collapse = []
        i = new
        while i is not None:
            if i is prev["item"]:
                return
            i = self.get(i["index"].parent())
            no_collapse.append(i)

        # Collapse previous item and all its parents, except if they're a
        # parent of the new item
        item = prev
        while item is not None:
            if item not in no_collapse and item["node"].auto_collapse is True:
                self.node_view.setExpanded(item["index"], False)
            item = self.get(item["index"].parent())

        # Set cursor to new item uniq_id
        self.cursor = new["node"].uniq_id

    def _ev_item_changed(self, item):
        logging.info("ev_item_changed: {}".format(item))
        index = self.node_model.indexFromItem(item)
        cur = self.get(index)
        text = item.text()

        cur["node"].title = text

        # Check for quick-icon-mapping where the user can start the title with
        # certain chars to change the icon.
        for key in quick_icon_map.keys():
            if text.startswith(key):
                new_text = text[len(key):]
                cur["node"].icon = quick_icon_map[key]
                cur["node"].title = new_text
                item.setText(new_text)
                item.setIcon(QIcon("icons/" + quick_icon_map[key]))
                break

        self.save(self.path)

    def _act_dump(self):
        cur = self.get()
        sys.stdout.write(repr(cur) + "\n")
        sys.stdout.flush()

        print(self.serialize(cur["item"]))

    def _act_delete(self):
        cur = self.get()
        children = self.serialize(cur["item"])
        self.del_buf = cur["node"].to_dict()
        self.del_buf["children"] = children
        self.node_model.removeRows(cur["index"].row(), 1, cur["index"].parent())

        self.save(self.path)

    def _act_paste_above(self):
        if self.del_buf is None:
            return

        cur = self.get()
        cur_row = cur["item"].row()

        node = Node.from_dict(self.del_buf)
        new_item = self.insert_node(node, cur["parent_item"], cur_row)
        self.deserialize(self.del_buf["children"], new_item)

    def _act_paste_below(self):
        if self.del_buf is None:
            return

        cur = self.get()
        cur_row = cur["item"].row()

        node = Node.from_dict(self.del_buf)
        new_item = self.insert_node(node, cur["parent_item"], cur_row + 1)
        self.deserialize(self.del_buf["children"], new_item)

    def _act_toggle_auto_collapse(self):
        cur = self.get()
        cur["node"].auto_collapse = not cur["node"].auto_collapse
        if cur["node"].auto_collapse is True:
            self.node_view.setExpanded(cur["index"], False)

    def _act_toggle_expanded(self):
        cur = self.get()
        inv_expanded = not self.node_view.isExpanded(cur["index"])
        self.node_view.setExpanded(cur["index"], inv_expanded)

    def _act_edit(self):
        cur = self.get()
        self.node_view.edit(cur["index"])

    def _act_insert_above(self):
        cur = self.get()
        cur_row = cur["index"].row()
        if cur_row > 0:
            prev = self.get(cur["index"].siblingAtRow(cur_row - 1))
        else:
            prev = self.get(cur["index"].siblingAtRow(0))

        # Create new node and insert
        new_node = prev["node"].copy()
        new_node.title = ""
        new_item = self.insert_node(new_node, cur["parent_item"], cur["row"])
        new_index = self.node_model.indexFromItem(new_item)

        # Edit the new node
        self.node_view.setCurrentIndex(new_index)
        self.node_view.edit(new_index)

    def _act_insert_below(self):
        cur = self.get()

        # Create new node and insert
        new_node = cur["node"].copy()
        new_node.title = ""
        new_item = self.insert_node(new_node, cur["parent_item"], cur["row"] + 1)
        new_index = self.node_model.indexFromItem(new_item)

        # Edit the new node
        self.node_view.setCurrentIndex(new_index)
        self.node_view.edit(new_index)

    def _act_move_up(self):
        cur = self.get()
        children = self.serialize(cur["item"])
        cur_row = cur["item"].row()
        cur_index_parent = cur["index"].parent()

        if cur_row == 0:
            # First item in list
            return

        self.node_model.removeRows(cur_row, 1, cur_index_parent)
        new_item = self.insert_node(cur["node"], cur["parent_item"], cur_row - 1)
        self.deserialize(children, new_item)
        new_index = self.node_model.indexFromItem(new_item)
        self.node_view.setCurrentIndex(new_index)
        cur_index = self.node_view.currentIndex()
        cur_item = self.node_model.itemFromIndex(cur_index)

    def _act_move_down(self):
        cur = self.get()
        children = self.serialize(cur["item"])
        cur_row = cur["item"].row()
        cur_index_parent = cur["index"].parent()

        if (cur_row + 1) == cur["parent_item"].rowCount():
            # Last item in list
            return

        self.node_model.removeRows(cur_row, 1, cur_index_parent)
        new_item = self.insert_node(cur["node"], cur["parent_item"], cur_row + 1)
        self.deserialize(children, new_item)
        new_index = self.node_model.indexFromItem(new_item)
        self.node_view.setCurrentIndex(new_index)

    def _act_cursor_up(self):
        cur = self.get()

        # Move to next row in current indent level
        new_index = cur["index"].siblingAtRow(cur["index"].row() - 1)
        if new_index.row() == -1:
            # Top of current indent. Move to parent
            new_index = cur["index"].parent()
            if new_index.row() == -1:
                # Don't do anything
                new_index = cur["index"]
        self.node_view.setCurrentIndex(new_index)

    def _act_cursor_down(self):
        cur = self.get()
        new_index = cur["index"].siblingAtRow(cur["index"].row() + 1)
        if new_index.row() != -1:
            self.node_view.setCurrentIndex(new_index)

    def _act_cursor_left(self):
        cur = self.get()
        new_index = self.node_model.indexFromItem(cur["parent_item"])

        # Focus
        if cur["item"].parent() is not None:
            self.node_view.setCurrentIndex(new_index)

    def _act_cursor_right(self):
        cur = self.get()
        has_children = self.node_model.hasChildren(cur["index"])

        if not has_children:
            # Add new child
            new_node = cur["node"].copy()
            new_node.title = ""
            new_item = self.insert_node(new_node, cur["item"])
            new_index = self.node_model.indexFromItem(new_item)

            # Edit the new node
            self.node_view.setCurrentIndex(new_index)
            self.node_view.edit(new_index)
        else:
            # Move into subtree
            self.node_view.setExpanded(cur["index"], True)
            new_index = self.node_view.moveCursor(QAbstractItemView.MoveRight,
                                                  Qt.NoModifier)
            self.node_view.setCurrentIndex(new_index)

    def _act_toggle_done(self):
        cur = self.get()
        cur["node"].checked = not cur["node"].checked
        cur["item"].setIcon(QIcon("icons/" + cur["node"].get_icon()))

        self.save(self.path)

    def _act_close(self, event=None):
        """
        Catch the user pressing the [X] button and cleanly close the app.
        """
        self.close()

    def _act_save(self):
        self.save(self.path)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--debug",
                        dest='debug',
                        action="store_true")
    parser.add_argument(metavar='PATH',
                        dest='path',
                        type=str)
    args = parser.parse_args()

    # Make sure ctrl-c on the commandline stops the application
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    if args.debug is True:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.WARN)

    # Backup file
    shutil.copy2(args.path, "{}.bak".format(args.path))

    # Lock file
    lock_path = "{}.lock".format(args.path)
    if os.path.exists(lock_path):
        sys.stderr.write("{} found. Aborting\n".format(lock_path))
        sys.exit(1)
    Path(lock_path).touch()

    # GUI
    app = QApplication([])
    gui = GUI(args.path)
    app.exec_()

    # Unlock
    os.unlink(lock_path)
